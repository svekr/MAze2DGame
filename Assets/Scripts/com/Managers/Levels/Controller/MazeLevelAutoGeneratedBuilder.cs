using System;
using System.Collections.Generic;
using com.MazeGame.Model;
using com.Settings;
using Extensions;
using Utils;

namespace com.Managers.Levels.Controller
{
  public class MazeLevelAutoGeneratedBuilder: ILevelBuilder<LevelModel>
  {
    private readonly RandomGatesHelper _gatesHelper = new RandomGatesHelper();
    private HashSet<CellModel> _visitedCells;

    public bool TryBuildLevel(object levelSettings, out LevelModel level) {
      level = null;
      LevelAutoGeneratedSettings settings = levelSettings as LevelAutoGeneratedSettings;
      if (settings == null) {
        return false;
      }
      CellModel[,] fieldModel = CreateMaze(settings.FieldSize.x, settings.FieldSize.y, settings.GatesCount);
      level = new LevelModel(settings.Id, fieldModel, settings.Duration);
      return true;
    }

    private CellModel[,] CreateMaze(int fieldSizeX, int fieldSizeY, int gatesCount)
    {
      CellModel[,] cells = InstantiateCells(fieldSizeX, fieldSizeY);
      _visitedCells = new HashSet<CellModel>(fieldSizeX * fieldSizeY);
      CellModel startCell = cells[fieldSizeX / 2, fieldSizeY - 1];
      _gatesHelper.Initialize(gatesCount);
      _gatesHelper.TryAddGatesCandidate(startCell, cells);
      RandomDFS(cells, startCell);
      _visitedCells.Clear();
      _gatesHelper.AddGates(cells);
      return cells;
    }

    private CellModel[,] InstantiateCells(int fieldSizeX, int fieldSizeY)
    {
      CellModel[,] result = new CellModel[fieldSizeX, fieldSizeY];
      for (int i = 0; i < fieldSizeX; i++)
      {
        for (int j = 0; j < fieldSizeY; j++)
        {
          result[i, j] = new CellModel(i, j);
        }
      }
      return result;
    }

    private void RandomDFS(CellModel[,] cells, CellModel cell)
    {
      _visitedCells.Add(cell);
      Direction direction = GetRandomUnvisitedNeighbourDirection(cells, cell);
      CellModel nextCell = FieldModelUtil.GetNeighbourCell(cell, direction, cells);
      if (nextCell == null) {
        _gatesHelper.TryAddGatesCandidate(cell, cells);
      }
      while (nextCell != null)
      {
        ConnectVertexes(cell, nextCell, direction);
        RandomDFS(cells, nextCell);
        direction = GetRandomUnvisitedNeighbourDirection(cells, cell);
        nextCell = FieldModelUtil.GetNeighbourCell(cell, direction, cells);
      }
    }

    private Direction GetRandomUnvisitedNeighbourDirection(CellModel[,] cells, CellModel cell)
    {
      Array directions = Enum.GetValues(typeof(Direction));
      directions.Shuffle();
      for (int i = 0; i < directions.Length; i++)
      {
        Direction direction = (Direction)directions.GetValue(i);
        CellModel neighbour = FieldModelUtil.GetNeighbourCell(cell, direction, cells);
        if (neighbour != null && !_visitedCells.Contains(neighbour))
        {
          return direction;
        }
      }
      return Direction.None;
    }

    private void ConnectVertexes(CellModel cell1, CellModel cell2, Direction direction)
    {
      cell1.Directions |= direction;
      cell2.Directions |= FieldModelUtil.InverseDirection(direction);
    }
  }
}